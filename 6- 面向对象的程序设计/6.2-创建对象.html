<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>6.2 创建对象</title>
    <script>
        //// 6.2.1 工厂模式
        function createPerson(name, age, job) {
            var o = new Object();
            o.name = name;
            o.age = age;
            o.job = job;
            o.sayName = function () {
                alert(this.name)
            }
            return o;
        }
        var person1 = createPerson("nikao", 24, "Software Engineer");
        // 特点:可以无数次调用这个函数，每次返回一个包含三个属性和一个方法的对象；
        // 缺点:不知道对象的类型；

        //// 6.2.2 构造函数模式
        // 使用构造函数将前面的例子重写；
        function Person(name, age, job) {
            this.name = name;
            this.age = age;
            this.job = job;
            this.sayName = function () {
                alert(this.name)
            }
        }
        var person1 = new Person("nikao", 23, "Software Engineer");
        // 与上述的例子相比，构造函数模式有以下几个不同之处；
        // 没有显示的创建对象；
        // 直接将属性和方法赋给了this对象；
        // 没有return语句；
        // 创建person的实例，使用了new操作符，以这种方式调用构造函数会经历以下过程；
        // 创建一个新对象；
        // 将构造函数的作用域赋给了新对象（也就是this指向了这个新对象）；
        // 执行构造函数的代码（为这个新对象添加属性和方法）；
        // 返回新的对象；
        // 检测对象类型
        // 用instancof操作符，创建的这个对象即是Object的实例，也是Person的实例
        // alert(person1 instanceof Object); //true   
        // alert(person1 instanceof Person); //true
        //// 1将构造函数当做函数
        // 当做构造函数使用
        var person = new Person("kaola", 24, "soft");
        console.log(person.name); //"kaola"
        // 作为普通股函数使用
        Person("faker", 20, "player");
        window.sayName(); //"faker"
        // 在另一对象的作用域中使用
        var o = new Object;
        Person.call(o, "mater", 23, "teacher")
        o.sayName(); // "mater"
        //// 2构造函数的问题
        // 每次实例化都有一个名为sayName()的方法，但每个sayName()方法不是同一个function的实例，因为函数是对象

        //// 6.2.3 原型模式
        function Persons() { };
        Persons.prototype.name = "Nichalas";
        Persons.prototype.age = 19;
        Persons.prototype.job = "Software Engineer";
        Persons.prototype.sayName = function () {
            alert(this.name)
        };
        var person1 = new Persons();
        person1.sayName(); //"Nichalas"
        var person2 = new Persons();
        person2.sayName(); //"Nichalas"
        console.log(person1.sayName==person2.sayName) //true

        //// 
        //// 1 理解原型对象
          // 创建一个新函数就会根据一组特定的规则为该函数创建一个prototype属性，这个属性
          // 指向函数的原型对象,在默认情况下,所有原型对象都活获得一个constructor属性(构造
          // 函数属性),这个属性包含一个指向prototype属性所在的指针
        //// 2 原型与in操作符
          // 有两种方式使用in操作符:单独使用和for-in循环中使用.在单独使用时,in操作符会在
          // 通过对象访问给定属性时返回true,无论该属性存在于实例中还是原型中 
           function Ren() { };
            Ren.prototype.name = "Nichalas";
            Ren.prototype.age = 19;
            Ren.prototype.job = "Software Engineer";
            Ren.prototype.sayName = function () {
                alert(this.name)
            };
            var newRen1=new Ren();
            var newRen2=new Ren();
            console.log(newRen1.hasOwnProperty("name")) // false
            console.log("name" in  newRen1) // true
            // 因此同时使用hasOwnProperty和in可以确定属性是存在于对象中,还是存在于原型中
            function hasPrototypeProperty(object,name){
                return !object.hasOwnProperty(name) && (name in object)
            }
        //// 4 原型的动态性
          // 由于在原型中查找值的过程是一次搜索,因此我们在原型中所做的任何修改都能在
          // 实例上反映出来-即使是先实例再修改原型
          var friend=new Ren();
          Ren.prototype.sayHi=function(){
              console.log("Hi")
          }
          friend.sayHi(); // "Hi" 
          // 原因是因为实例与原型之间的松散连接关系,
        //// 6 原型对象的问题
          // 1:省略了为构造函数初始化参数这一环节,结果所有实例再默认情况下都将取得相同的属性值
          // 2:原型模式最大的问题是由其共享本质导致的(对于包含引用类型的属性来说,问题比较突出)
          function PersonCha(){

          }
          PersonCha.prototype={
              constructor:PersonCha,
              name:'marton',
              age:"23",
              friends:["a","b"]
          }
          var newPersonCha1=new PersonCha();
          var newPersonCha2=new PersonCha();
          newPersonCha1.friends.push("c");
          console.log(newPersonCha1.friends.toString()); // a,b,c
          console.log(newPersonCha2.friends.toString()); // a,b,c
        //// 6.2.4 组合使用构造函数模式和原型模式
          // 构造函数模式:用于定义实例属性
          // 原型模式:用于定义方法和共享的属性
          // 结果:每个实例都有一份属于自己的实例属性的副本,同时共享着对方法的引用,最大限度的节省了内存
          function Personss(name,age,job){
              this.name=name;
              this.age=age;
              this.job=job;
              this.friends=["a","b"]
          }
          Personss.prototype={
              constructor:Person,
              sayName:function(){
                  console.log(this)
                  console.log(this.name)
              }.bind(Personss)
          }
          var person1=new Personss("faker",22,"player");
          var person2=new Personss("panxiaoting",40,'sport');
          person1.friends.push("c");
          console.log(person1.friends.toString()); // a,b,c
          console.log(person2.friends.toString()); // a,b
          console.log(person1.sayName()==person2.sayName())
    </script>
</head>

<body>

</body>

</html>